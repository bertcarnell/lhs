<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Latin Hypercube Samples (lhs): oacpp::COrthogonalArray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Latin Hypercube Samples (lhs)
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">R, C++, and Rcpp code to generate Latin hypercube samples</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classoacpp_1_1_c_orthogonal_array.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoacpp_1_1_c_orthogonal_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">oacpp::COrthogonalArray Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_orthogonal_array_8h_source.html">COrthogonalArray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7ad35affcb1377a7c7bd2a8d00fa7674"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a7ad35affcb1377a7c7bd2a8d00fa7674">COrthogonalArray</a> ()</td></tr>
<tr class="separator:a7ad35affcb1377a7c7bd2a8d00fa7674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663ccf848ea55ed7d0a7d74239463fe7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a663ccf848ea55ed7d0a7d74239463fe7">~COrthogonalArray</a> ()</td></tr>
<tr class="separator:a663ccf848ea55ed7d0a7d74239463fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82714bdda728354150233c07f92d736c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a82714bdda728354150233c07f92d736c">addelkemp</a> (int q, int k, int *n)</td></tr>
<tr class="separator:a82714bdda728354150233c07f92d736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbedf9583f97688056ca9fb4c04b54d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#afcbedf9583f97688056ca9fb4c04b54d">addelkemp3</a> (int q, int k, int *n)</td></tr>
<tr class="separator:afcbedf9583f97688056ca9fb4c04b54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06dbbb771be9a96588af7cbcc31d05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a6f06dbbb771be9a96588af7cbcc31d05">addelkempn</a> (int akn, int q, int k, int *n)</td></tr>
<tr class="separator:a6f06dbbb771be9a96588af7cbcc31d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3895c4257996c82ed70081524e1222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a3d3895c4257996c82ed70081524e1222">bose</a> (int q, int k, int *n)</td></tr>
<tr class="separator:a3d3895c4257996c82ed70081524e1222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73875575343a969f9c067eebb09aad6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a73875575343a969f9c067eebb09aad6f">bosebush</a> (int q, int k, int *n)</td></tr>
<tr class="separator:a73875575343a969f9c067eebb09aad6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eab0f0edb805006ce6cde282d4d5e4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a6eab0f0edb805006ce6cde282d4d5e4d">bosebushl</a> (int lambda, int q, int k, int *n)</td></tr>
<tr class="separator:a6eab0f0edb805006ce6cde282d4d5e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecfb0dacfc39bc31c78864c074a35b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a0ecfb0dacfc39bc31c78864c074a35b8">bush</a> (int q, int k, int *n)</td></tr>
<tr class="separator:a0ecfb0dacfc39bc31c78864c074a35b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad251d1401182d05e6d01323ea00848c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#ad251d1401182d05e6d01323ea00848c5">busht</a> (int str, int q, int k, int *n)</td></tr>
<tr class="separator:ad251d1401182d05e6d01323ea00848c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878b84d443bf4127b3ecb146d994ac03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a878b84d443bf4127b3ecb146d994ac03">oaagree</a> (bool verbose)</td></tr>
<tr class="separator:a878b84d443bf4127b3ecb146d994ac03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4b6a0550b159c67b49ba93580c3c63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a3b4b6a0550b159c67b49ba93580c3c63">oatriple</a> (bool verbose)</td></tr>
<tr class="separator:a3b4b6a0550b159c67b49ba93580c3c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2baccbfd0c4ae1587e84ff7ef23bbe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#ad2baccbfd0c4ae1587e84ff7ef23bbe4">oadimen</a> ()</td></tr>
<tr class="separator:ad2baccbfd0c4ae1587e84ff7ef23bbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49593d2455ad741422cbbd1aeb24867"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#ae49593d2455ad741422cbbd1aeb24867">oarand</a> (int is, int js, int ks, int ls)</td></tr>
<tr class="separator:ae49593d2455ad741422cbbd1aeb24867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4aa0fedc1f43aa132de0cf807e115cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#ad4aa0fedc1f43aa132de0cf807e115cb">oastr</a> (bool verbose)</td></tr>
<tr class="separator:ad4aa0fedc1f43aa132de0cf807e115cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4986bd1845da1224472e8a24104c875"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#ab4986bd1845da1224472e8a24104c875">oastr1</a> (bool verbose)</td></tr>
<tr class="separator:ab4986bd1845da1224472e8a24104c875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f543d5c6df67f66f4f4d1fa034d72c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a3f543d5c6df67f66f4f4d1fa034d72c1">oastr2</a> (bool verbose)</td></tr>
<tr class="separator:a3f543d5c6df67f66f4f4d1fa034d72c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cfcc928f1987ec0c9821c7e142c1df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a72cfcc928f1987ec0c9821c7e142c1df">oastr3</a> (bool verbose)</td></tr>
<tr class="separator:a72cfcc928f1987ec0c9821c7e142c1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce5e7b737d299bb2c64af4163e58d77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#adce5e7b737d299bb2c64af4163e58d77">oastr4</a> (bool verbose)</td></tr>
<tr class="separator:adce5e7b737d299bb2c64af4163e58d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3200f22d26d804c9a9dcbc4993496f27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a3200f22d26d804c9a9dcbc4993496f27">oastrt</a> (int t, bool verbose)</td></tr>
<tr class="separator:a3200f22d26d804c9a9dcbc4993496f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4095fc6f58fd0cfc6580e38a8247f560"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a4095fc6f58fd0cfc6580e38a8247f560">getnrows</a> ()</td></tr>
<tr class="separator:a4095fc6f58fd0cfc6580e38a8247f560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f78d7a3e50edeba0682601e55d79089"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a9f78d7a3e50edeba0682601e55d79089">getncols</a> ()</td></tr>
<tr class="separator:a9f78d7a3e50edeba0682601e55d79089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd48b4c5fd4b41198d2f0dd63d68747e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#afd48b4c5fd4b41198d2f0dd63d68747e">getq</a> ()</td></tr>
<tr class="separator:afd48b4c5fd4b41198d2f0dd63d68747e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b39d58348ae1fcf080152ebe5589160"><td class="memItemLeft" align="right" valign="top">const bclib::matrix&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html#a8b39d58348ae1fcf080152ebe5589160">getoa</a> ()</td></tr>
<tr class="separator:a8b39d58348ae1fcf080152ebe5589160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Orthogonal Array Class</p>
<p>A collection of functions used as an API for Art Owen's oa library. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7ad35affcb1377a7c7bd2a8d00fa7674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad35affcb1377a7c7bd2a8d00fa7674">&#9670;&nbsp;</a></span>COrthogonalArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">oacpp::COrthogonalArray::COrthogonalArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default Constructor </p>

</div>
</div>
<a id="a663ccf848ea55ed7d0a7d74239463fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663ccf848ea55ed7d0a7d74239463fe7">&#9670;&nbsp;</a></span>~COrthogonalArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">oacpp::COrthogonalArray::~COrthogonalArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a82714bdda728354150233c07f92d736c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82714bdda728354150233c07f92d736c">&#9670;&nbsp;</a></span>addelkemp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::addelkemp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an orthogonal array using the Addelman Kempthorne algorithm</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>The addelkemp program produces <code>OA( 2q^2, k, q, 2 ), k &lt;= 2q+1</code>, for odd prime powers <code>q</code>. Even prime powers may be produced using bosebush above. This construction is based on:</p>
<p><b>S. Addelman and O. Kempthorne (1961) Annals of Mathematical Statistics, Vol 32 pp 1167-1176.</b></p>
<p>using <code>n=2</code> in their notation.</p>
<p><code>2q</code> columns can be constructed without a coincidence defect. Setting <code>k=2q+1</code> leads to an array with the coincidence defect. Some triples of columns contain duplicate rows. (The lack of a coincidence defect has been verified for <code>q = 2,3,4,5,7,9,11,13,17,19,23,25</code> and <code>k = 2q</code>.)</p>
<p>This construction should work for all prime powers <code>q</code>, but it failed to do so for even powers greater than 4. This may have been a programming error, or it may have stemmed from misunderstanding of the description of the algorithm. The program rejects requests with <code>q = 2^r</code> for <code>r &gt; 2</code>. The Bose Bush construction handles these cases.</p>
<p>The description of the construction for odd prime powers calls for some arithmetic involving the number 4. In Galois fields with <code>3^r</code> elements, there is no 4. Replacing 4 by 1 for these fields works when <code>q = 3,9,27</code> (brute force verification). </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">q</td><td>the number of symbols <code>(0,...,q-1)</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">k</td><td>the number of columns in the array. <code>k &lt;= q+1</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>the number of rows in the array, <code>n = 2q^2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcbedf9583f97688056ca9fb4c04b54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbedf9583f97688056ca9fb4c04b54d">&#9670;&nbsp;</a></span>addelkemp3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::addelkemp3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an orthogonal array using the Addelman Kempthorne algorithm</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>The addelkemp3 program produces <code>OA( 2*q^3, k, q, 2 ), k &lt;= 2q^2+2q+1</code>, for prime powers <code>q</code>. <code>q</code> may be an odd prime power, or <code>q</code> may be 2 or 4.</p>
<p>This construction is based on:</p>
<p><b>S. Addelman and O. Kempthorne (1961) Annals of Mathematical Statistics, Vol 32 pp 1167-1176.</b></p>
<p>using <code>n=3</code> in their notation.</p>
<p>Coincidences are much harder to understand with these designs. For example <code>addelkemp3 3 9</code> does lead to a number of triple coincidences, that is pairs of rows in which 3 columns agree, but no quadruple coincidences. <code>addelkemp3 9 28</code> produces an extra column that figures in some quadruple coincidences.</p>
<p>As for addelkemp above, 4 is replaced by 1 in fields that do not have an element 4. Also powers of 2 larger than 4 are not allowed, as described above for addelkemp.</p>
<p>The article is quite vague on this. Page 1173 states "When n&gt;2 the same procedure will yield the desired plans
if Lemma 5a is used in place of Lemma 5." Page 1175 provides the example n=3,q=3 which is OA( 54,25,3,2 ). Based on this example it is possible to make an educated guess as to how the construction generalizes to n=3. The resulting OA's are seen, by brute force to be of strength 2 for q=2,3,4,5,7,11. These OAs are:</p><ul>
<li>OA(   16,  13,  2, 2 )</li>
<li>OA(   54,  25,  3, 2 )</li>
<li>OA(  128,  41,  4, 2 )</li>
<li>OA(  250,  61,  5, 2 )</li>
<li>OA(  686, 113,  7, 2 )</li>
<li>OA( 1458, 181,  9, 2 )</li>
<li>OA( 2662, 265, 11, 2 )</li>
</ul>
<p>The one with q=7 required 212709392 comparisons to determine that it really is of strength 2. This took roughly 11.5 minutes on a DEC 5000/240 workstation (real and elapsed in this case). The array with q=11 took 1.12671e+10 comparisons to verify its strength. This took roughly 10 1/2 hours.</p>
<p>For even q, only q= 2 or 4 are available. The prescription given in Addelman and Kempthorne (1961) does not appear to work. Commented out code below attempts to implement that prescription. It seemed to be impossible to find a constant b[1],c[1] pair. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">q</td><td>the number of symbols <code>(0,...,q-1)</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">k</td><td>the number of columns in the array. <code>k &lt;= 2q^2+2q+1</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>the number of rows in the array, <code>n = 2q^3</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f06dbbb771be9a96588af7cbcc31d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f06dbbb771be9a96588af7cbcc31d05">&#9670;&nbsp;</a></span>addelkempn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::addelkempn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>akn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an orthogonal array using the Addelman Kempthorne algorithm</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This method is not included by default in Art Owens's project. The method is in the code, but it is not compiled in the makefile. Adding it as a target to the makefile creates a successful build, but running addelkempn 3 3 (which should be equivalent to addelkemp3 3) does not function in the MinGW64 build.</dd></dl>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>The article is quite vague on this. Page 1173 states "When n&gt;2 the same procedure will yield the desired plans
if Lemma 5a is used in place of Lemma 5." Page 1175 provides the example n=3,q=3 which is OA( 54,25,3,2 ). Based on this example it is possible to make an educated guess as to how the construction generalizes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">akn</td><td>the exponent on <code>q</code> for the number of rows <code>n = 2q^akn</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">q</td><td>the number of symbols <code>(0,...,q-1)</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">k</td><td>the number of columns in the array. <code>k &lt;= 2(q^akn-1)/(q-1) - 1</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>the number of rows in the array, <code>n = 2q^akn</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td></td></tr>
  </table>
  </dd>
</dl>
</blockquote>

</div>
</div>
<a id="a3d3895c4257996c82ed70081524e1222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3895c4257996c82ed70081524e1222">&#9670;&nbsp;</a></span>bose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::bose </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an orthogonal array using the Bose algorithm</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>The bose program produces <code>OA( q^2, k, q, 2 ), k &lt;= q+1 </code> for prime powers <code>q</code>. This is based on:</p>
<p><b>R.C. Bose (1938) Sankhya Vol 3 pp 323-338</b> </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">q</td><td>the number of symbols <code>(0,...,q-1)</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">k</td><td>the number of columns in the array. <code>k &lt;= q+1</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>the number of rows in the array, <code>n = q^2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73875575343a969f9c067eebb09aad6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73875575343a969f9c067eebb09aad6f">&#9670;&nbsp;</a></span>bosebush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::bosebush </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an orthogonal array using the Bose-Bush algorithm</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>The bosebush program produces <code>OA( 2q^2, k, q, 2 ), k &lt;= 2q+1</code>, for powers of 2, <code>q = 2^r</code>. This construction is based on:</p>
<p><b>R.C. Bose and K.A. Bush (1952) Annals of Mathematical Statistics, Vol 23 pp 508-524.</b></p>
<p><code>2q</code> columns can be constructed without a coincidence defect. Setting <code>k = 2q+1</code> leads to an array with the coincidence defect. Some triples of columns contain duplicate rows. (The lack of a coincidence defect has been verified for <code>q = 2,4,8,16,32</code> and <code>k = 2q</code>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">q</td><td>the number of symbols <code>(0,...,q-1)</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">k</td><td>the number of columns in the array. <code>k &lt;= q+1</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>the number of rows in the array, <code>n = q^2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eab0f0edb805006ce6cde282d4d5e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eab0f0edb805006ce6cde282d4d5e4d">&#9670;&nbsp;</a></span>bosebushl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::bosebushl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an orthogonal array using the Bose-Bush algorithm</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>The bosebushl program produces <code>OA( lambda*q^2, k, q, 2 ),</code></p>
<p><code>k &lt;= lambda*q+1</code>, for prime powers <code>q</code> and <code>lambda &gt; 1</code>. Both <code>q</code> and <code>lambda</code> must be powers of the same prime. This construction is based on:</p>
<p><b>R.C. Bose and K.A. Bush (1952) Annals of Mathematical Statistics, Vol 23 pp 508-524.</b></p>
<p>Coincidences are harder to understand with these designs. For example <code>bosebushl 3 9</code> does lead to a number of triple coincidences, that is pairs of rows in which 3 columns agree, but no quadruple coincidences. <code>bosebush 3 9 28</code> produces an extra column that figures in some quadruple coincidences.</p>
<p>The arrays produced by this program are not always the largest possible. The article by Bose and Bush cited above describes ways of adjoining some extra columns.</p>
<p>When <code>k &lt;= lambda*q</code>, the program produces an array that is "completely resolvable". What this means is that the rows of the array may be split into lambda*q consecutive nonoverlapping sets of rows each of which is <code>OA( q,k,q,1 )</code>. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td></td></tr>
    <tr><td class="paramname">q</td><td></td></tr>
    <tr><td class="paramname">k</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ecfb0dacfc39bc31c78864c074a35b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecfb0dacfc39bc31c78864c074a35b8">&#9670;&nbsp;</a></span>bush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::bush </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an orthogonal array using the Bush algorithm</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>The bush program produces <code>OA( q^3, k, q, 3 ), k &lt;= q+1</code> for prime powers <code>q</code>. This strength 3 construction is based on:</p>
<p><b>K.A. Bush (1952) Annals of Mathematical Statistics, Vol 23 pp 426-434</b></p>
<p>This construction is the most commonly used special case of busht given below. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">q</td><td>the number of symbols <code>(0,...,q-1)</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">k</td><td>the number of columns in the array. <code>k &lt;= q+1</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>the number of rows in the array, <code>n = q^3</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad251d1401182d05e6d01323ea00848c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad251d1401182d05e6d01323ea00848c5">&#9670;&nbsp;</a></span>busht()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::busht </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an orthogonal array using the Bush algorithm</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>The bush program produces <code>OA( q^t, k, q, t ), k &lt;= q+1, t&gt;=3</code>, for prime powers <code>q</code>. This strength <code>t</code> construction is based on:</p>
<p><b>K.A. Bush (1952) Annals of Mathematical Statistics, Vol 23 pp 426-434</b> </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">q</td><td></td></tr>
    <tr><td class="paramname">k</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f78d7a3e50edeba0682601e55d79089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f78d7a3e50edeba0682601e55d79089">&#9670;&nbsp;</a></span>getncols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oacpp::COrthogonalArray::getncols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>column accessor </p><dl class="section return"><dt>Returns</dt><dd>the number of columns in the orthogonal array </dd></dl>

</div>
</div>
<a id="a4095fc6f58fd0cfc6580e38a8247f560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4095fc6f58fd0cfc6580e38a8247f560">&#9670;&nbsp;</a></span>getnrows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oacpp::COrthogonalArray::getnrows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>row accessor </p><dl class="section return"><dt>Returns</dt><dd>the number of rows in the orthogonal array </dd></dl>

</div>
</div>
<a id="a8b39d58348ae1fcf080152ebe5589160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b39d58348ae1fcf080152ebe5589160">&#9670;&nbsp;</a></span>getoa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bclib::matrix&lt; int &gt; &amp; oacpp::COrthogonalArray::getoa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>orthogonal array accessor </p><dl class="section return"><dt>Returns</dt><dd>the orthogonal array </dd></dl>

</div>
</div>
<a id="afd48b4c5fd4b41198d2f0dd63d68747e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd48b4c5fd4b41198d2f0dd63d68747e">&#9670;&nbsp;</a></span>getq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oacpp::COrthogonalArray::getq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>symbol accessor </p><dl class="section return"><dt>Returns</dt><dd>the number of symbols in the orthogonal array </dd></dl>

</div>
</div>
<a id="a878b84d443bf4127b3ecb146d994ac03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878b84d443bf4127b3ecb146d994ac03">&#9670;&nbsp;</a></span>oaagree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oacpp::COrthogonalArray::oaagree </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of columns for which each pair of rows agree</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>This program counts the number of columns in which each pair of distinct rows agree.</p>
<p>Input is described above under OA input conventions. </p>
</blockquote>
<p>Examples: </p><blockquote class="doxtable">
<p><code><a class="el" href="classoacpp_1_1_c_orthogonal_array.html">COrthogonalArray</a> coa; int n; coa.addelkemp3(3, 25, &amp;n); coa.oagree(true);</code> </p>
</blockquote>
<p>This example finds that in OA( 54, 25, 3, 2 ) produced by addelkemp3 there exist pairs of rows agreeing in 9 columns. The first rows to attain this are rows 0 and 9, the 1st and 10th rows.</p>
<blockquote class="doxtable">
<p><code><a class="el" href="classoacpp_1_1_c_orthogonal_array.html">COrthogonalArray</a> coa; int n; coa.addelkemp3(3, 24, &amp;n); coa.agree(true);</code> </p>
</blockquote>
<p>The second example finds that in OA( 54, 24, 3, 2 ) produced by addelkemp3 there exist pairs of rows agreeing in 8 columns. No pairs of rows agree in 9 columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Should messages be printed about the findings? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum number of agreeing columns </dd></dl>

</div>
</div>
<a id="ad2baccbfd0c4ae1587e84ff7ef23bbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2baccbfd0c4ae1587e84ff7ef23bbe4">&#9670;&nbsp;</a></span>oadimen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::oadimen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the dimension of the orthogonal array </p>

</div>
</div>
<a id="ae49593d2455ad741422cbbd1aeb24867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49593d2455ad741422cbbd1aeb24867">&#9670;&nbsp;</a></span>oarand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oacpp::COrthogonalArray::oarand </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>js</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Randomize an orthogonal array</p>
<p>From the original documentation </p><blockquote class="doxtable">
<p>This program permutes the symbols in each column. The permutations are uniformly distributed (all <code>q!</code> permutations have the same probability) and all columns are permuted independently.</p>
<p>Input is described above under OA input conventions, with exceptions noted below to allow passing a random seed. If oarand is called twice with the same input array, the same permuted output will result both times, unless different seeds are given.</p>
<p>The random number generator is a version of the Marsaglia-Zaman random number generator, transliterated into C from FORTRAN. The seed must be four integers between 1 and 168 inclusive, with not all values equal to 1. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>seed </td></tr>
    <tr><td class="paramname">js</td><td>seed </td></tr>
    <tr><td class="paramname">ks</td><td>seed </td></tr>
    <tr><td class="paramname">ls</td><td>seed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4aa0fedc1f43aa132de0cf807e115cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4aa0fedc1f43aa132de0cf807e115cb">&#9670;&nbsp;</a></span>oastr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oacpp::COrthogonalArray::oastr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the strength of an orthogonal array</p>
<p>This program reads an orthogonal array strength by brute force computation. In addition to the strength <code>t</code> described above under the heading orthogonal arrays, strength 0 is taken to mean that the array indeed has all its elements in the range 0..q-1.</p>
<p>An array of strength <code>t &gt; 0</code> is also of strength <code>s</code> for all <code>0 &lt;= s &lt; t</code>. The program starts testing <code>t = 0</code> and increases <code>t</code> until it finds <code>t</code> for which the array is not strength <code>t</code>.</p>
<p>Finding the strength of an array by brute force is lightning fast for small arrays but very slow for larger arrays. When the job is large enough, intermediate results are printed so the user can decide whether or not to kill the job, based on how much progress is being made.</p>
<p>The function that calculates strength has an argument verbose. In oastr the array strength function is called with verbose=2. This prints to standard output a description of progress as the strength check proceeds. If one wants to use this function in other settings, calling it with verbose=1 shuts off standard output but leaves the warnings to standard error, and verbose=0 shuts off all output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>should diagnostic message be printed? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the strength of the array </dd></dl>

</div>
</div>
<a id="ab4986bd1845da1224472e8a24104c875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4986bd1845da1224472e8a24104c875">&#9670;&nbsp;</a></span>oastr1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool oacpp::COrthogonalArray::oastr1 </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to oastr, but only checking strength 1</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>Check whether the array in standard input is really of strength 1. Use brute force. For OA( nrow, ncol, q, ? ) it takes work roughly proportional to ncol * nrow * q to decide if ? &gt;= 1. The user is warned if this is likely to be too much work.</p>
<p>The program calls exit(0) if the input array has strength</p><ol type="1">
<li>It calls exit(1) if the array is not of strength 1, or if the input is invalid, or if it is impossible to allocate enough memory to find out.</li>
</ol>
<p>Note that an array of strength larger than 1 is a fortiori of strength 1 and will pass this test.</p>
<p></p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>should diagnostic message be printed? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the array is strength 1 </dd></dl>

</div>
</div>
<a id="a3f543d5c6df67f66f4f4d1fa034d72c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f543d5c6df67f66f4f4d1fa034d72c1">&#9670;&nbsp;</a></span>oastr2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool oacpp::COrthogonalArray::oastr2 </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to oastr, but only checking strength 2</p>
<p>From the original documentation </p><blockquote class="doxtable">
<p>Check whether the array in standard input is really of strength 2. Use brute force. For OA( nrow, ncol, q, ? ) it takes work roughly proportional to ncol^2 * nrow * q^2/2 to decide if ? &gt;= 2. The user is warned if this is likely to be too much work.</p>
<p>The program calls exit(0) if the input array has strength</p><ol type="1">
<li>It calls exit(1) if the array is not of strength 2, or if the input is invalid, or if it is impossible to allocate enough memory to find out.</li>
</ol>
<p>The program exits at the first sign that the array is not of strength 2. This can save lots of work if the problem shows up early, but it doesn't give a complete list of the array's shortcomings. Such a list could be very large.</p>
<p>Note that an array of strength larger than 2 is a fortiori of strength 2 and will pass this test. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>should diagnostic message be printed? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the array is strength 2 </dd></dl>

</div>
</div>
<a id="a72cfcc928f1987ec0c9821c7e142c1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72cfcc928f1987ec0c9821c7e142c1df">&#9670;&nbsp;</a></span>oastr3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool oacpp::COrthogonalArray::oastr3 </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to oastr, but only checking strength 3 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>should diagnostic message be printed? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the array is strength 3 </dd></dl>

</div>
</div>
<a id="adce5e7b737d299bb2c64af4163e58d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce5e7b737d299bb2c64af4163e58d77">&#9670;&nbsp;</a></span>oastr4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool oacpp::COrthogonalArray::oastr4 </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to oastr, but only checking strength 4 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>should diagnostic message be printed? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the array is strength 4 </dd></dl>

</div>
</div>
<a id="a3200f22d26d804c9a9dcbc4993496f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3200f22d26d804c9a9dcbc4993496f27">&#9670;&nbsp;</a></span>oastrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool oacpp::COrthogonalArray::oastrt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to oastr, but only checking for strength t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the strength to check for </td></tr>
    <tr><td class="paramname">verbose</td><td>should diagnostic messages be printed? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b4b6a0550b159c67b49ba93580c3c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4b6a0550b159c67b49ba93580c3c63">&#9670;&nbsp;</a></span>oatriple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oacpp::COrthogonalArray::oatriple </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of columns for which each three rows agree</p>
<p>From the original documentation: </p><blockquote class="doxtable">
<p>This program reports on triple coincidences. For all triples of distinct columns, it counts the number of distinct pairs of rows in which the triple of columns agree.</p>
<p>Input is described above under OA input conventions.</p>
<p>Examples:</p>
<p><code><a class="el" href="classoacpp_1_1_c_orthogonal_array.html">COrthogonalArray</a> coa; int n; coa.bosebush(8, 16, &amp;n); coa.agree(true);</code></p>
<p>There are 0 distinct triples of columns that agree in at least two distinct rows.</p>
<p><code><a class="el" href="classoacpp_1_1_c_orthogonal_array.html">COrthogonalArray</a> coa; int n; coa.bosebush(8, 17, &amp;n); coa.agree(true);</code></p>
<p>Warning: The Bose-Bush construction with ncol = 2q+1 has a defect. While it is still an OA(2q^2,2q+1,q,2), there exist some pairs of rows that agree in three columns.</p>
<p>There are 8 distinct triples of columns that agree in at least two distinct rows.</p>
<p>The warning above is generated by bosebush. The rest shows that there are triple coincidences. Notice that they all involve the 17th column (which is column 16, since the first one is column 0). The other 16 columns can be organized into 8 pairs with each pair forming a triple with column 16 and no other triples agreeing in any row. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Should messages be printed about the findings? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum number of agreeing columns </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_c_orthogonal_array_8h_source.html">COrthogonalArray.h</a></li>
<li>src/<a class="el" href="_c_orthogonal_array_8cpp.html">COrthogonalArray.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoacpp.html">oacpp</a></li><li class="navelem"><a class="el" href="classoacpp_1_1_c_orthogonal_array.html">COrthogonalArray</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
